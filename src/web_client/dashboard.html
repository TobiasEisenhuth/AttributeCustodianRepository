<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>CRS — Dashboard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="/app/favicon.ico">
  <link rel="stylesheet" href="/app/style.css">
  <style>
    .muted { color:#666; }
    .ok { color:#0a5; }
    .warn { color:#b60; }
    .err { color:#b00; }
    .row { display:flex; gap:.5rem; align-items:center; flex-wrap:wrap; }
    .spacer { flex:1; }
    .chip { display:inline-block; padding:.15rem .5rem; border-radius:999px; font-size:.85rem; border:1px solid #ddd; }
    .chip.ok { border-color:#0a5; color:#0a5; }
    .chip.warn { border-color:#b60; color:#b60; }
    .chip.err { border-color:#b00; color:#b00; }
    .tabs { display:flex; gap:.5rem; margin-top:.75rem; }
    .tabs button[aria-selected="true"] { background:#222; color:#fff; }
    .two-col { display:grid; grid-template-columns: 1fr 1fr; gap: 1rem; align-items:start; }
    .list { border:1px solid #ddd; border-radius:.5rem; padding:.5rem; max-height: 50vh; overflow:auto; }
    .item { padding:.3rem .4rem; border-bottom:1px dashed #eee; }
    .item:last-child { border-bottom:none; }
    .reqgrid { display:grid; gap:.5rem; }
    .reqcell { border:1px dashed #ccc; border-radius:.5rem; min-height:2.2rem; padding:.35rem .5rem; background:#fafafa; }
    .reqcell.filled { border-style:solid; background:#fff; }
    .reqcell.skipped { opacity:.5; text-decoration: line-through; }
    .dragging { opacity:.6; }
    .hidden { display:none !important; }
    .busy { opacity:.6; pointer-events:none; }
    .small { font-size:.85rem; }
    .reqrow { display:flex; gap:.5rem; flex-wrap:wrap; }

    /* lightweight modal */
    .modal { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; }
    .modal.hidden { display:none !important; }
    .modal .backdrop { position:absolute; inset:0; background:rgba(0,0,0,.25); }
    .modal .sheet { position:relative; background:#fff; border:1px solid #ddd; border-radius:.75rem; padding:1rem; width:min(520px, 92vw); box-shadow:0 10px 24px rgba(0,0,0,.15); }
    .modal h3 { margin:.25rem 0 .75rem; }
    .modal label { display:block; font-size:.9rem; margin:.5rem 0 .25rem; }
    .modal input { width:100%; }
    .btn-primary { background:#1f6feb; color:#fff; border:none; padding:.45rem .75rem; border-radius:.5rem; }
    .btn-ghost { background:#f5f5f5; color:#111; border:1px solid #ddd; padding:.45rem .75rem; border-radius:.5rem; }
  </style>
</head>
<body class="center">
  <div class="card" id="card">
    <h1>Dashboard</h1>

    <div class="row" style="margin-top:.25rem;">
      <div id="email" class="muted"></div>
      <div class="spacer"></div>
      <div id="vault-state" class="chip muted">Loading…</div>
    </div>

    <div class="row" style="margin-top:.5rem;">
      <button id="save">Save now</button>
      <button id="download" title="Download encrypted vault blob (backup)">Download backup</button>
      <div class="spacer"></div>
      <button id="clear-passkey" title="Forget the in-tab vault key">Clear passkey</button>
      <button id="logout">Log out</button>
    </div>

    <p id="status" class="muted" style="margin-top:.5rem;">Initializing…</p>

    <div class="tabs">
      <button id="tab-requester" aria-selected="true">Requester</button>
      <button id="tab-provider">Provider</button>
      <button id="btn-refresh" class="spacer small">Refresh solicitations</button>
    </div>

    <!-- REQUESTER VIEW (unchanged) -->
    <section id="view-requester">
      <h2>New solicitation</h2>
      <div class="row">
        <label>Provider ID (UUID)
          <input id="rq-provider-id" class="small" placeholder="provider_id (UUID)" />
        </label>
        <label>Field description
          <input id="rq-field-desc" class="small" placeholder="e.g. Street name" />
        </label>
        <label>Example format
          <input id="rq-example" class="small" placeholder="e.g. Baker" />
        </label>
        <label>Order (row.col)
          <input id="rq-order" class="small" placeholder="0.0" />
        </label>
        <button id="rq-add" title="Add row to this draft">Add row</button>
        <button id="rq-clear" title="Discard draft">Discard</button>
        <div class="spacer"></div>
        <button id="rq-send" class="ok" title="Send solicitation and persist rows">Send solicitation</button>
      </div>

      <div class="list" id="rq-draft" style="margin-top:.5rem;">
        <!-- draft rows render here -->
      </div>
    </section>

    <!-- PROVIDER VIEW -->
    <section id="view-provider" class="hidden">
      <div class="two-col" style="margin-top:.5rem;">
        <div>
          <h2>Your secrets</h2>
          <div id="pv-inventory" class="list small">Loading…</div>
          <div class="row" style="margin-top:.5rem;">
            <button id="pv-add-item" class="btn-primary">Add Item</button>
          </div>
        </div>
        <div>
          <h2>Incoming request</h2>
          <div class="row small">
            <div id="pv-req-meta" class="muted">No bundle loaded.</div>
            <div class="spacer"></div>
            <button id="pv-grant-all" disabled>Grant all</button>
            <button id="pv-skip-bundle" disabled>Skip</button>
          </div>
          <div id="pv-req-grid" class="reqgrid" style="margin-top:.5rem;"></div>
        </div>
      </div>
    </section>
  </div>

  <!-- Modal: Add Item -->
  <div id="add-item-modal" class="modal hidden" aria-hidden="true">
    <div class="backdrop"></div>
    <div class="sheet">
      <h3>New Item</h3>
      <label>Item Name (display)</label>
      <input id="mi-display" placeholder="e.g. Shoe Size" />
      <label>Value</label>
      <input id="mi-value" placeholder="e.g. 45" />
      <div class="row" style="margin-top: .75rem;">
        <div class="spacer"></div>
        <button id="mi-cancel" class="btn-ghost">Cancel</button>
        <button id="mi-add" class="btn-primary">Add</button>
      </div>
      <p id="mi-hint" class="muted small" style="margin-top:.5rem;">
        The internal <em>item_id</em> will be derived from the display name (lowercase, spaces → underscores).
      </p>
    </div>
  </div>

  <script type="module">
    import { CRSClient } from "/app/crs-sdk.js";
    const api = new CRSClient();

    // ---------- Utilities ----------
    const enc = new TextEncoder();
    const dec = new TextDecoder();
    const emailEl = document.getElementById("email");
    const statusEl = document.getElementById("status");
    const card = document.getElementById("card");

    function setStatus(text, cls="muted"){ statusEl.textContent = text; statusEl.className = cls; }
    function setBusy(flag){ card.classList.toggle("busy", !!flag); }
    function nowIso(){ return new Date().toISOString(); }
    function bytesToBase64(bytes){ let s=""; for (const b of bytes) s+=String.fromCharCode(b); return btoa(s); }
    function base64ToBytes(b64){ const s=atob(b64); const a=new Uint8Array(s.length); for(let i=0;i<s.length;i++) a[i]=s.charCodeAt(i); return a; }
    function concatBytes(a,b){ const out=new Uint8Array(a.length+b.length); out.set(a,0); out.set(b,a.length); return out; }

    function normalizeDisplay(s) {
      return (s || "").trim().replace(/\s+/g, " ");
    }
    function toItemId(display) {
      return normalizeDisplay(display)
        .toLowerCase()
        .replace(/\s+/g, "_")
        .replace(/[^a-z0-9_]/g, "")
        .replace(/_+/g, "_")
        .replace(/^_+|_+$/g, "");
    }

    // ---------- Session prelims ----------
    const email = (sessionStorage.getItem("crs:email") || "").trim();
    emailEl.textContent = email ? `Signed in as ${email}` : "";
    const passkey_b64 = sessionStorage.getItem("crs:passkey");
    if (!passkey_b64) {
      try { await api.logout(); } catch {}
      location.replace("/app/login.html");
      throw new Error("No passkey in this tab.");
    }

    // ---------- Crypto: import key for vault (AES-GCM) ----------
    const aesKey = await crypto.subtle.importKey(
      "raw",
      base64ToBytes(passkey_b64),
      { name: "AES-GCM" },
      false,
      ["encrypt", "decrypt"]
    );
    // Keep the passkey in sessionStorage for the life of this tab

    // ---------- Encrypted vault baseline ----------
    const stateChip = document.getElementById("vault-state");
    function setStateChip(text, kind="muted") {
      stateChip.textContent = text;
      stateChip.className = `chip ${kind}`;
    }

    const emailKey = email ? `:${email}` : "";
    const CACHE_KEY = `crs:vault_cache${emailKey}`;
    const LAST_SAVED_KEY = `crs:vault_last_saved${emailKey}`;

    const store = {
      version: 1,
      created_at: nowIso(),
      updated_at: nowIso(),
      private: {
        provider: { secrets: [], groups: {}, synonyms: {} },
        requester: { requests: [], keypairs: {}, history: [] },
      },
      ephemeral: { ui: {} }
    };

    function ensureVaultShape(obj) {
      if (!obj || typeof obj !== "object") throw new Error("Vault missing root object");
      if (obj.version != null && obj.version !== 1) throw new Error("Unsupported vault version");
      if (!obj.private || typeof obj.private !== "object") obj.private = {};
      if (!obj.private.provider || typeof obj.private.provider !== "object") obj.private.provider = {};
      const pv = obj.private.provider;
      if (!Array.isArray(pv.secrets)) pv.secrets = [];
      if (!pv.groups || typeof pv.groups !== "object") pv.groups = {};
      if (!pv.synonyms || typeof pv.synonyms !== "object") pv.synonyms = {};
      if (!obj.private.requester || typeof obj.private.requester !== "object") obj.private.requester = {};
      const rq = obj.private.requester;
      if (!Array.isArray(rq.requests)) rq.requests = [];
      if (!rq.keypairs || typeof rq.keypairs !== "object") rq.keypairs = {};
      if (!Array.isArray(rq.history)) rq.history = [];
      if (!obj.meta || typeof obj.meta !== "object") obj.meta = { schema: "crs/v1", owner: email || "" };
      return obj;
    }

    let encryptedBlobB64 = "";
    let lastSavedB64 = localStorage.getItem(LAST_SAVED_KEY) || "";
    let dirty = false, saving = false, saveError = "";

    function updateButtons() {
      document.getElementById("save").disabled = saving || (!dirty && !saveError);
      document.getElementById("download").disabled = !encryptedBlobB64;
    }

    // ---------- Vault encrypt/decrypt ----------
    async function encryptAndCachePrivate() {
      const payload = JSON.stringify({
        version: store.version,
        created_at: store.created_at,
        updated_at: nowIso(),
        private: store.private,
      });
      store.updated_at = JSON.parse(payload).updated_at;

      const iv = new Uint8Array(12); crypto.getRandomValues(iv);
      const ctBuf = await crypto.subtle.encrypt({ name:"AES-GCM", iv }, aesKey, enc.encode(payload));
      const ct = new Uint8Array(ctBuf);
      const blob = concatBytes(iv, ct);
      encryptedBlobB64 = bytesToBase64(blob);

      try {
        localStorage.setItem(CACHE_KEY, JSON.stringify({
          ts: Date.now(),
          b64: encryptedBlobB64,
          note: "AES-GCM: bytes = nonce(12) || ciphertext||tag(16); base64-encoded",
          email, version: store.version,
        }));
      } catch {}
      dirty = (encryptedBlobB64 !== lastSavedB64);
      saveError = "";
      updateUiState();
    }

    async function decryptBlobToStore(b64) {
      const blob = base64ToBytes(b64);
      if (blob.length < 12+16) throw new Error("Vault blob too short");
      const iv = blob.slice(0,12);
      const ct = blob.slice(12);
      const ptBuf = await crypto.subtle.decrypt({ name:"AES-GCM", iv }, aesKey, ct);
      const obj = JSON.parse(dec.decode(new Uint8Array(ptBuf)));

      ensureVaultShape(obj);
      store.version    = obj.version ?? 1;
      store.created_at = obj.created_at || store.created_at;
      store.updated_at = obj.updated_at || nowIso();
      store.private    = obj.private;
      store.ephemeral  = { ui: {} };
    }

    async function loadVault() {
      setStateChip("Loading…");
      setStatus("Loading vault…");
      try {
        const res = await api.loadFromVault();
        const b64 = res?.encrypted_localstore_b64;
        if (!b64 || typeof b64 !== "string") throw new Error("Bad vault payload");
        await decryptBlobToStore(b64);
        encryptedBlobB64 = b64;
        lastSavedB64 = b64;
        try { localStorage.setItem(LAST_SAVED_KEY, lastSavedB64); } catch {}
        try { localStorage.setItem(CACHE_KEY, JSON.stringify({ ts: Date.now(), b64, email, version: store.version })); } catch {}
        dirty = false;
        setStateChip("Synced", "ok");
        setStatus("Vault loaded from server.", "ok");
      } catch (e) {
        const cached = JSON.parse(localStorage.getItem(CACHE_KEY) || "null");
        if (cached?.b64) {
          try {
            await decryptBlobToStore(cached.b64);
            encryptedBlobB64 = cached.b64;
            dirty = true;
            setStateChip("Unsaved (from cache)", "warn");
            setStatus("Loaded vault from local cache (server unavailable).", "warn");
          } catch {
            setStateChip("Error", "err");
            setStatus("Could not decrypt cached vault. Wrong key or corrupted data.", "err");
          }
        } else {
          setStatus("No server vault. Starting with an empty local store.", "warn");
          ensureVaultShape(store);
          await encryptAndCachePrivate();
          setStateChip("Unsaved", "warn");
        }
      } finally { updateButtons(); }
    }

    async function saveToServer({ timeoutMs = 7000 } = {}) {
      if (!encryptedBlobB64) await encryptAndCachePrivate();
      saving = true; saveError = ""; updateUiState();

      const ac = new AbortController();
      const t = setTimeout(() => ac.abort(), timeoutMs);

      try {
        await api.saveToVault(encryptedBlobB64, { signal: ac.signal });
        lastSavedB64 = encryptedBlobB64;
        try { localStorage.setItem(LAST_SAVED_KEY, lastSavedB64); } catch {}
        dirty = false; saving = false; saveError = "";
        setStateChip("Synced", "ok");
        setStatus("Saved to server.", "ok");
      } catch (e) {
        saving = false;
        if (e?.status === 413 || String(e?.data?.error).includes("payload_too_large")) {
          saveError = "Vault too large for server. Download the encrypted backup.";
          setStateChip("Too large", "err");
          setStatus(saveError, "err");
        } else if (e?.name === "AbortError") {
          saveError = "Save timed out. Check your connection or try again.";
          setStateChip("Timed out", "err");
          setStatus(saveError, "err");
        } else {
          saveError = e?.data?.detail || e?.message || "Save failed.";
          setStateChip("Error", "err");
          setStatus(saveError, "err");
        }
        dirty = true;
      } finally {
        clearTimeout(t);
        updateButtons();
      }
    }

    function updateUiState() {
      if (saving) setStateChip("Saving…", "warn");
      else if (saveError) setStateChip("Error", "err");
      else if (dirty) setStateChip("Unsaved", "warn");
      else setStateChip("Synced", "ok");
      updateButtons();
    }

    // ---------- Buttons (vault) ----------
    document.getElementById("save").addEventListener("click", async () => {
      await encryptAndCachePrivate(); await saveToServer({ timeoutMs: 7000 });
    });
    document.getElementById("download").addEventListener("click", () => {
      if (!encryptedBlobB64) return;
      const blob = new Blob([encryptedBlobB64], { type: "text/plain" });
      const a = document.createElement("a");
      const ts = new Date().toISOString().replace(/[:.]/g,"-");
      a.href = URL.createObjectURL(blob);
      a.download = `crs-vault-encrypted-${ts}.b64.txt`;
      document.body.appendChild(a); a.click();
      setTimeout(() => { URL.revokeObjectURL(a.href); a.remove(); }, 0);
    });
    document.getElementById("clear-passkey").addEventListener("click", () => {
      try { sessionStorage.removeItem("crs:passkey"); sessionStorage.removeItem("crs:email"); } catch {}
      setStatus("Passkey cleared for this tab.", "warn");
    });
    document.getElementById("logout").addEventListener("click", async () => {
      document.getElementById("logout").disabled = true;
      try { if (dirty) await saveToServer({ timeoutMs: 7000 }); } catch {}
      try { await api.logout(); } catch {}
      location.href = "/app/login.html";
    });

    // ---------- Tabs ----------
    const viewRequester = document.getElementById("view-requester");
    const viewProvider = document.getElementById("view-provider");
    const tabRequester = document.getElementById("tab-requester");
    const tabProvider = document.getElementById("tab-provider");
    function showView(which) {
      tabRequester.setAttribute("aria-selected", String(which === "rq"));
      tabProvider.setAttribute("aria-selected", String(which === "pv"));
      viewRequester.classList.toggle("hidden", which !== "rq");
      viewProvider.classList.toggle("hidden", which !== "pv");
    }
    tabRequester.addEventListener("click", () => showView("rq"));
    tabProvider.addEventListener("click", () => showView("pv"));

    // ---------- Umbral JS loader ----------
    let U = null;
    async function loadUmbral() {
      if (U) return U;
      try {
        const mod = await import("/app/umbral/umbral_pre_wasm.js");
        if (typeof mod.default === "function") {
          await mod.default("/app/umbral/umbral_pre_wasm_bg.wasm");
        }
        U = mod;
        return U;
      } catch (e) {
        console.error("Umbral import/init failed:", e);
        setStatus("Umbral WASM not available; PRE actions disabled.", "warn");
        return null;
      }
    }

    // ---------- ID helpers ----------
    function randBytes(n){ const a=new Uint8Array(n); crypto.getRandomValues(a); return a; }
    function b64url(bytes){ return bytesToBase64(bytes).replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,''); }
    function newSecretId(){ return b64url(randBytes(12)); }

    // ============================================================
    // ===============  REQUESTER (minimal) =======================
    // ============================================================
    const rqProviderId = document.getElementById("rq-provider-id");
    const rqFieldDesc = document.getElementById("rq-field-desc");
    const rqExample   = document.getElementById("rq-example");
    const rqOrder     = document.getElementById("rq-order");
    const rqAdd       = document.getElementById("rq-add");
    const rqClear     = document.getElementById("rq-clear");
    const rqSend      = document.getElementById("rq-send");
    const rqDraftBox  = document.getElementById("rq-draft");

    let rqDraft = [];

    function renderRqDraft() {
      rqDraftBox.innerHTML = "";
      if (rqDraft.length === 0) {
        rqDraftBox.textContent = "No draft rows yet.";
        return;
      }
      for (const row of rqDraft) {
        const div = document.createElement("div");
        div.className = "item";
        div.textContent = `[${row.request_order}] ${row.field_description} — e.g. “${row.value_example_format}”`;
        rqDraftBox.appendChild(div);
      }
    }

    rqAdd.addEventListener("click", async () => {
      const provider_id = rqProviderId.value.trim();
      const field_description = rqFieldDesc.value.trim();
      const value_example_format = rqExample.value.trim();
      const request_order = (rqOrder.value.trim() || "0.0");
      if (!provider_id || !field_description) {
        setStatus("Provider ID and Field description are required.", "err");
        return;
      }
      const umbral = await loadUmbral();
      if (!umbral) { setStatus("Umbral not loaded.", "err"); return; }

      const sk = umbral.SecretKey.random();
      const pk = sk.publicKey();

      const secret_id = newSecretId();
      rqDraft.push({
        provider_id,
        field_description,
        value_example_format,
        default_field: null,
        request_order,
        secret_id,
        requester_public_key_b64: bytesToBase64(pk.toCompressedBytes()),
        __sk_be_b64: bytesToBase64(sk.toBEBytes()),
        __pk_b64: bytesToBase64(pk.toCompressedBytes()),
      });
      setStatus("Row added to draft.", "ok");
      renderRqDraft();
    });

    rqClear.addEventListener("click", () => {
      rqDraft = [];
      renderRqDraft();
      setStatus("Draft cleared.", "warn");
    });

    rqSend.addEventListener("click", async () => {
      if (rqDraft.length === 0) { setStatus("Nothing to send.", "warn"); return; }
      const provider_id = rqDraft[0].provider_id;
      if (!rqDraft.every(r => r.provider_id === provider_id)) {
        setStatus("All draft rows must target the same provider.", "err");
        return;
      }
      setBusy(true);
      try {
        const rows = rqDraft.map(r => ({
          field_description: r.field_description,
          secret_id: r.secret_id,
          value_example_format: r.value_example_format,
          requester_public_key_b64: r.requester_public_key_b64,
          default_field: r.default_field,
          request_order: r.request_order
        }));
        await api.pushSolicitation(provider_id, { rows });

        const finalized = rqDraft.map(r => ({
          provider_id,
          secret_id: r.secret_id,
          field_description: r.field_description,
          default_field: r.default_field,
          value_example_format: r.value_example_format,
          request_order: r.request_order,
          keys: {
            secret_key_b64: r.__sk_be_b64,
            public_key_b64: r.__pk_b64,
          },
          provider_public_key_b64: null,
          provider_verifying_key_b64: null
        }));
        store.private.requester.requests.push(...finalized);
        await encryptAndCachePrivate();
        await saveToServer({ timeoutMs: 7000 });

        rqDraft = [];
        renderRqDraft();
        setStatus("Solicitation sent and saved.", "ok");
      } catch (e) {
        setStatus(e?.message || "Failed to send solicitation.", "err");
      } finally {
        setBusy(false);
      }
    });

    // ============================================================
    // ==================  PROVIDER (minimal)  ====================
    // ============================================================
    const pvInventory = document.getElementById("pv-inventory");

    async function loadInventory() {
      pvInventory.textContent = "Loading…";
      try {
        const res = await api.listMyItems();
        const items = res?.items || [];
        if (items.length === 0) { pvInventory.textContent = "(no secrets uploaded)"; return; }

        const byId = Object.fromEntries((store.private.provider.secrets || []).map(s => [s.secret_id, s]));
        pvInventory.innerHTML = "";
        const umbral = await loadUmbral();
        for (const it of items) {
          const row = document.createElement("div");
          row.className = "item small";
          const meta = byId[it.item_id];
          let valueStr = "(no key in vault or Umbral not available)";
          if (umbral && meta?.keys?.secret_key_b64) {
            try {
              const sk = umbral.SecretKey.fromBEBytes(base64ToBytes(meta.keys.secret_key_b64));
              const capsule = umbral.Capsule.fromBytes(base64ToBytes(it.capsule_b64));
              const ciphertext = base64ToBytes(it.ciphertext_b64);
              const plaintext = umbral.decryptOriginal(sk, capsule, ciphertext);
              valueStr = new TextDecoder().decode(plaintext);
            } catch (_e) {
              valueStr = "(decrypt failed)";
            }
          }
          row.textContent = `${meta?.secret_name || it.item_id} — ${valueStr}`;
          row.draggable = true;
          row.dataset.secretId = it.item_id;
          row.dataset.value = valueStr;
          row.addEventListener("dragstart", e => {
            row.classList.add("dragging");
            e.dataTransfer.setData("text/plain", JSON.stringify({
              secret_id: it.item_id,
              value: valueStr
            }));
          });
          row.addEventListener("dragend", () => row.classList.remove("dragging"));
          pvInventory.appendChild(row);
        }
      } catch (e) {
        pvInventory.textContent = `Inventory error: ${e?.message || e}`;
      }
    }

    const pvMeta = document.getElementById("pv-req-meta");
    const pvGrid = document.getElementById("pv-req-grid");
    const pvGrantAll = document.getElementById("pv-grant-all");
    const pvSkip = document.getElementById("pv-skip-bundle");

    let currentBundle = null;      // { requester_id, bundle: { requests[], ack_token } }
    let currentRows = [];          // flattened rows across the bundle
    let mapping = new Map();       // requester_secret_id -> provider_secret_id
    let skipped = new Set();       // requester_secret_id toggled off
    let inflightGrant = false;
    let inflightBundleKey = null;

    function parseOrder(rc) {
      if (typeof rc === "number") return { r: rc, c: 0 };
      const m = String(rc || "0.0").match(/^(\d+)\.(\d+)$/);
      return m ? { r: +m[1], c: +m[2] } : { r: 0, c: 0 };
    }

    function buildGrid(rows) {
      const cells = rows.map(x => ({ ...x, rc: parseOrder(x.request_order) }))
                        .sort((a,b) => (a.rc.r - b.rc.r) || (a.rc.c - b.rc.c));

      const byRow = new Map();
      for (const r of cells) {
        if (!byRow.has(r.rc.r)) byRow.set(r.rc.r, []);
        byRow.get(r.rc.r).push(r);
      }

      pvGrid.innerHTML = "";
      for (const entries of byRow.values()) {
        const rowEl = document.createElement("div");
        rowEl.className = "reqrow";

        for (const r of entries) {
          const cell = document.createElement("div");
          cell.className = "reqcell";
          cell.dataset.reqSecretId = r.secret_id;
          cell.innerHTML = `
            <div class="small"><strong>${r.field_description}</strong> <span class="muted">(${r.request_order ?? "0.0"})</span></div>
            <div class="small muted">e.g. ${r.value_example_format}</div>
            <div class="small" data-fill></div>
          `;

          cell.addEventListener("dragover", e => e.preventDefault());
          cell.addEventListener("drop", e => {
            e.preventDefault();
            if (!currentBundle) return;
            try {
              const { secret_id: provSid, value } = JSON.parse(e.dataTransfer.getData("text/plain"));
              mapping.set(r.secret_id, provSid);
              skipped.delete(r.secret_id);
              cell.classList.add("filled");
              cell.classList.remove("skipped");
              cell.querySelector("[data-fill]").textContent = value;
            } catch {}
            refreshGrantButton();
          });

          cell.addEventListener("click", () => {
            const sid = r.secret_id;
            if (skipped.has(sid)) {
              skipped.delete(sid);
              cell.classList.remove("skipped");
            } else {
              skipped.add(sid);
              mapping.delete(sid);
              cell.classList.remove("filled");
              cell.classList.add("skipped");
              cell.querySelector("[data-fill]").textContent = "";
            }
            refreshGrantButton();
          });

          rowEl.appendChild(cell);
        }

        pvGrid.appendChild(rowEl);
      }
    }

    function refreshGrantButton() {
      if (!currentBundle) { pvGrantAll.disabled = true; pvSkip.disabled = true; return; }
      const reqIds = currentRows.map(r => r.secret_id);
      const actionable = reqIds.some(id => mapping.has(id) || skipped.has(id));
      pvGrantAll.disabled = !actionable || inflightGrant;
      pvSkip.disabled = inflightGrant;
    }

    async function pullSolicitationsOnce() {
      if (inflightBundleKey) return;
      try {
        const res = await api.pullSolicitationBundle();
        if (!res?.has_bundle) {
          pvMeta.textContent = "No pending requests.";
          currentBundle = null; currentRows = [];
          pvGrid.innerHTML = ""; mapping.clear(); skipped.clear();
          refreshGrantButton();
          return;
        }
        currentBundle = res;
        inflightBundleKey = JSON.stringify(res.bundle.ack_token);

        // Flatten all rows across requests
        const rawReqs = Array.isArray(res.bundle?.requests) ? res.bundle.requests : [];
        currentRows = rawReqs.flatMap(req => Array.isArray(req?.payload?.rows) ? req.payload.rows : []);

        pvMeta.textContent = `Requester: ${res.requester_id} — ${currentRows.length} field(s)`;
        mapping.clear(); skipped.clear();
        buildGrid(currentRows);
        refreshGrantButton();
      } catch (e) {
        setStatus(`Pull error: ${e?.message || e}`, "err");
      }
    }

    document.getElementById("btn-refresh").addEventListener("click", pullSolicitationsOnce);
    setInterval(pullSolicitationsOnce, 60_000);

    pvSkip.addEventListener("click", () => {
      currentBundle = null; inflightBundleKey = null; currentRows = [];
      pvGrid.innerHTML = ""; mapping.clear(); skipped.clear();
      pvMeta.textContent = "Bundle cleared (not acked).";
      refreshGrantButton();
    });

    pvGrantAll.addEventListener("click", async () => {
      if (!currentBundle) return;
      const umbral = await loadUmbral();
      if (!umbral) { setStatus("Umbral not loaded; cannot grant.", "err"); return; }

      const providerSecretsById = Object.fromEntries(
        (store.private.provider.secrets || []).map(s => [s.secret_id, s])
      );

      const reqRows = currentRows;
      const toGrant = reqRows.filter(r => mapping.has(r.secret_id));
      const toSkip  = reqRows.filter(r => skipped.has(r.secret_id));

      if (toGrant.length === 0 && toSkip.length === 0) {
        setStatus("Nothing selected to grant/skip.", "warn");
        return;
      }

      inflightGrant = true; setBusy(true); refreshGrantButton();

      const failures = [];
      for (const r of toGrant) {
        const provSid = mapping.get(r.secret_id);
        const provEntry = providerSecretsById[provSid];
        if (!provEntry?.keys?.secret_key_b64 || !provEntry?.keys?.signing_key_b64) {
          failures.push({ r, error: "Missing provider secret/signing key in vault." });
          continue;
        }
        try {
          const delegating_sk = umbral.SecretKey.fromBEBytes(base64ToBytes(provEntry.keys.secret_key_b64));
          const signer_sk     = umbral.SecretKey.fromBEBytes(base64ToBytes(provEntry.keys.signing_key_b64));
          const signer        = new umbral.Signer(signer_sk);
          const receiving_pk  = umbral.PublicKey.fromCompressedBytes(base64ToBytes(r.requester_public_key_b64));

          const kfrags = umbral.generateKFrags(
            delegating_sk, receiving_pk, signer,
            1, 1, true, true
          );

          const kfrags_b64 = kfrags.map(k => bytesToBase64(k.toBytes()));
          await api.grantAccess({
            requester_id: currentBundle.requester_id,
            provider_item_id: provSid,
            requester_item_id: r.secret_id,
            kfrags_b64,
          });
        } catch (e) {
          failures.push({ r, error: e?.message || String(e) });
        }
      }

      if (failures.length === 0) {
        try {
          const ackBody = {
            requester_id: currentBundle.requester_id,
            max_created_at: currentBundle.bundle.ack_token.max_created_at,
            max_request_id: currentBundle.bundle.ack_token.max_request_id,
          };
          const r = await fetch("/api/ack_solicitation_bundle", {
            method: "POST",
            credentials: "include",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(ackBody),
          });
          if (!r.ok) {
            const data = await r.json().catch(() => ({}));
            const err = new Error("ACK failed");
            err.status = r.status; err.data = data; throw err;
          }

          setStatus("All grants sent and bundle acked.", "ok");
          currentBundle = null; inflightBundleKey = null; currentRows = [];
          pvGrid.innerHTML = ""; mapping.clear(); skipped.clear();
          pvMeta.textContent = "Bundle processed.";
        } catch (e) {
          setStatus("Grants succeeded but ACK failed. You can retry ACK with Refresh.", "warn");
        }
      } else {
        setStatus(`Some grants failed (${failures.length}). Fix and retry.`, "err");
      }

      inflightGrant = false; setBusy(false); refreshGrantButton();
    });

    // ---------- Add Item (Provider) ----------
    const addItemBtn = document.getElementById("pv-add-item");
    const addModal = document.getElementById("add-item-modal");
    const miDisplay = document.getElementById("mi-display");
    const miValue = document.getElementById("mi-value");
    const miCancel = document.getElementById("mi-cancel");
    const miAdd = document.getElementById("mi-add");

    function openAddModal() {
      miDisplay.value = "";
      miValue.value = "";
      addModal.classList.remove("hidden");
      addModal.setAttribute("aria-hidden", "false");
      setTimeout(() => miDisplay.focus(), 0);
    }
    function closeAddModal() {
      addModal.classList.add("hidden");
      addModal.setAttribute("aria-hidden", "true");
    }
    addItemBtn.addEventListener("click", openAddModal);
    addModal.querySelector(".backdrop").addEventListener("click", closeAddModal);
    miCancel.addEventListener("click", closeAddModal);

    miAdd.addEventListener("click", async () => {
      const display = normalizeDisplay(miDisplay.value);
      const valueStr = String(miValue.value ?? "");
      const item_id = toItemId(display);

      if (!display || !item_id) { setStatus("Please provide an item name.", "err"); return; }
      if (!valueStr) { setStatus("Please provide a value.", "err"); return; }

      const umbral = await loadUmbral();
      if (!umbral) { setStatus("Umbral not loaded; cannot add item.", "err"); return; }

      setBusy(true);
      try {
        // generate keys (delegating + signing)
        const delegating_sk = umbral.SecretKey.random();
        const delegating_pk = delegating_sk.publicKey();
        const signing_sk = umbral.SecretKey.random();
        const verifying_pk = signing_sk.publicKey();

        // encrypt the value for the provider (original ciphertext)
        const ptBytes = enc.encode(valueStr);
        const { capsule, ciphertext } = umbral.encryptOriginal(delegating_pk, ptBytes);

        // send to server
        await api.upsertItem({
          item_id,
          capsule_b64: bytesToBase64(capsule.toBytes()),
          ciphertext_b64: bytesToBase64(ciphertext),
          provider_public_key_b64: bytesToBase64(delegating_pk.toCompressedBytes()),
          provider_verifying_key_b64: bytesToBase64(verifying_pk.toCompressedBytes()),
        });

        // persist keys + metadata in vault
        const newEntry = {
          secret_id: item_id,
          secret_name: display,
          keys: {
            secret_key_b64: bytesToBase64(delegating_sk.toBEBytes()),
            signing_key_b64: bytesToBase64(signing_sk.toBEBytes()),
          },
          created_at: nowIso(),
          updated_at: nowIso(),
        };

        const arr = store.private.provider.secrets || (store.private.provider.secrets = []);
        const idx = arr.findIndex(s => s.secret_id === item_id);
        if (idx === -1) arr.push(newEntry);
        else arr[idx] = { ...arr[idx], ...newEntry, updated_at: nowIso() };

        await encryptAndCachePrivate();
        await saveToServer({ timeoutMs: 7000 });

        setStatus(`Item "${display}" saved.`, "ok");
        closeAddModal();
        await loadInventory(); // show it right away
      } catch (e) {
        setStatus(e?.message || "Failed to add item.", "err");
      } finally {
        setBusy(false);
      }
    });

    // ---------- Page lifecycle autosave on unload ----------
    addEventListener("pagehide", async () => {
      if (!dirty) return;
      try {
        await fetch("/api/save_to_vault", {
          method: "PUT",
          credentials: "include",
          keepalive: true,
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ encrypted_localstore_b64: encryptedBlobB64 }),
        });
      } catch {}
    });

    // ---------- Init ----------
    await loadVault();
    await loadInventory();
    await pullSolicitationsOnce();
  </script>
</body>
</html>
