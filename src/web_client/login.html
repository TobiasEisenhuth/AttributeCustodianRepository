<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>CRS — Sign in / Register</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="/app/favicon.ico">
  <link rel="stylesheet" href="/app/style.css">
  <style>
    .row { display:flex; gap:.5rem; align-items:center; }
    .buttons { display:flex; gap:.5rem; margin-top:.75rem; flex-wrap:wrap; }
    .buttons.right { justify-content:flex-end; }
    .error { color:#b00; min-height:1.25rem; }
    .ok { color:#0a5; min-height:1.25rem; }
    .muted { color:#666; font-size:.9rem; }
    .hint { font-size:.9rem; color:#444; }
    .hidden { display:none; }
    label > span { display:block; font-size:.85rem; color:#333; margin-bottom:.25rem; }
    input[type="password"] { letter-spacing:0.05em; }

    .overlay {
      position: absolute; inset: 0; display:none;
      background: rgba(255,255,255,0.65);
      backdrop-filter: blur(1px);
      align-items:center; justify-content:center; flex-direction:column; gap:.5rem;
      z-index: 10;
    }
    .overlay.show { display:flex; }
    .spinner {
      width: 28px; height: 28px; border-radius: 50%;
      border: 3px solid #999; border-top-color: transparent;
      animation: spin 0.8s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    .gate {
      position: fixed; inset: 0; display:none;
      background: rgba(0,0,0,0.45);
      align-items: center; justify-content: center;
      padding: 1rem; z-index: 20;
    }
    .gate.show { display:flex; }
    .gate-card {
      background: #fff; color: #111; max-width: 760px; width: 100%;
      border-radius: 12px; padding: 1rem; box-shadow: 0 4px 24px rgba(0,0,0,0.25);
      display: flex; flex-direction: column; gap: .75rem;
    }
    .gate-card h2 { margin: 0; }
    .gate-card .filename { font-family: monospace; background: #f3f3f3; padding: .25rem .5rem; border-radius: 6px; }
    .gate-card textarea {
      width: 100%; min-height: 220px; resize: vertical; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      border: 1px solid #ddd; border-radius: 8px; padding: .5rem; background: #fafafa; color:#222;
    }
    .gate-actions { display:flex; gap:.5rem; justify-content: flex-end; align-items:center; flex-wrap: wrap; }
    .gate-actions .left { margin-right: auto; display:flex; align-items:center; gap:.5rem; }
  </style>
</head>
<body class="center">
  <div class="card" id="card" aria-live="polite" style="position:relative;">
    <h1>Welcome</h1>

    <div id="chooser" class="buttons" style="justify-content:center; margin-top:1rem;">
      <button id="choose-login"  type="button">Login</button>
      <button id="choose-register" type="button">Register</button>
    </div>

    <!-- Login form -->
    <form id="login-form" class="hidden" autocomplete="on">
      <div class="row" style="margin-top:.5rem">
        <label style="flex:1">
          <span>Email</span>
          <input id="login-email" name="email" type="email" required autocomplete="username" />
        </label>
      </div>
      <div class="row" style="margin-top:.5rem">
        <label style="flex:1">
          <span>Password</span>
          <input id="login-password" name="password" type="password" required minlength="15" autocomplete="current-password" />
        </label>
        <label class="inline" title="Show password" style="display:flex; align-items:center; gap:.5rem;">
          <input id="login-showpw" type="checkbox" />
          <span class="muted">Show</span>
        </label>
      </div>
      <div class="row" style="margin-top:.5rem">
        <label style="flex:1">
          <span>Salt file (.json)</span>
          <input id="login-saltfile" name="saltfile" type="file" accept=".json,application/json" required />
        </label>
      </div>
      <div class="buttons" style="justify-content:space-between;">
        <button id="btn-back-from-login" type="button" class="muted">← Back</button>
        <div class="buttons right">
          <button id="btn-login" type="button">Login</button>
        </div>
      </div>
      <p id="login-error" class="error" role="alert"></p>
      <p id="login-ok" class="ok" role="status"></p>
    </form>

    <!-- Register form -->
    <form id="register-form" class="hidden" autocomplete="on">
      <div class="row" style="margin-top:.5rem">
        <label style="flex:1">
          <span>Email</span>
          <input id="reg-email" name="email" type="email" required autocomplete="username" />
        </label>
      </div>
      <div class="row" style="margin-top:.5rem">
        <label style="flex:1">
          <span>Password</span>
          <input id="reg-password" name="password" type="password" required minlength="15" autocomplete="new-password" />
        </label>
        <label class="inline" title="Show password" style="display:flex; align-items:center; gap:.5rem;">
          <input id="reg-showpw" type="checkbox" />
          <span class="muted">Show</span>
        </label>
      </div>
      <p class="hint" style="margin-top:.5rem;">
        On registration we’ll create a <strong>device salt file</strong> (your second factor).
        We will only offer it for download <em>after</em> the server confirms registration (or if the connection times out).
        The <code>email</code> inside the file is optional and may be removed.
      </p>
      <div class="buttons" style="justify-content:space-between;">
        <button id="btn-back-from-register" type="button" class="muted">← Back</button>
        <div class="buttons right">
          <button id="btn-register" type="button">Create account</button>
        </div>
      </div>
      <p id="reg-error" class="error" role="alert"></p>
      <p id="reg-ok" class="ok" role="status"></p>
    </form>

    <!-- Busy overlay -->
    <div id="overlay" class="overlay" aria-hidden="true">
      <div class="spinner" role="status" aria-label="Working…"></div>
      <div class="muted" id="overlay-text">Contacting server…</div>
    </div>

    <!-- Salt Gate -->
    <div id="salt-gate" class="gate" role="dialog" aria-modal="true" aria-labelledby="salt-gate-title" aria-describedby="salt-gate-desc">
      <div class="gate-card">
        <h2 id="salt-gate-title">Save your device salt file</h2>
        <p id="salt-gate-desc" class="muted">
          This file is required to log in from this device (and others if you copy it). Keep it safe.
          The <code>email</code> field is optional and only for your recognition; you may blank/remove it.
        </p>
        <div class="muted">Suggested filename: <span class="filename" id="salt-filename">crs-salt.json</span></div>
        <textarea id="salt-json" readonly spellcheck="false" aria-label="Salt file JSON"></textarea>
        <div class="gate-actions">
          <label class="left">
            <input id="salt-confirm" type="checkbox" />
            <span class="muted">I saved the file</span>
          </label>
          <button id="btn-download-salt" type="button">Download salt file</button>
          <button id="btn-continue" type="button" class="hidden">Continue to Dashboard</button>
          <button id="btn-go-login" type="button" class="hidden">Go to Login</button>
        </div>
        <p id="salt-note" class="muted"></p>
      </div>
    </div>
  </div>

  <script type="module">
    import { CRSClient } from "/app/crs-sdk.js";
    const api = new CRSClient();

    // Elements
    const card = document.getElementById("card");
    const overlay = document.getElementById("overlay");
    const overlayText = document.getElementById("overlay-text");
    const chooser = document.getElementById("chooser");
    const chooseLogin = document.getElementById("choose-login");
    const chooseRegister = document.getElementById("choose-register");

    const loginForm = document.getElementById("login-form");
    const loginEmail = document.getElementById("login-email");
    const loginPassword = document.getElementById("login-password");
    const loginShowpw = document.getElementById("login-showpw");
    const loginSaltfile = document.getElementById("login-saltfile");
    const btnLogin = document.getElementById("btn-login");
    const btnBackFromLogin = document.getElementById("btn-back-from-login");
    const loginErr = document.getElementById("login-error");
    const loginOk = document.getElementById("login-ok");

    const regForm = document.getElementById("register-form");
    const regEmail = document.getElementById("reg-email");
    const regPassword = document.getElementById("reg-password");
    const regShowpw = document.getElementById("reg-showpw");
    const btnRegister = document.getElementById("btn-register");
    const btnBackFromRegister = document.getElementById("btn-back-from-register");
    const regErr = document.getElementById("reg-error");
    const regOk = document.getElementById("reg-ok");

    const saltGate = document.getElementById("salt-gate");
    const saltJsonEl = document.getElementById("salt-json");
    const saltFilenameEl = document.getElementById("salt-filename");
    const saltConfirm = document.getElementById("salt-confirm");
    const btnDownloadSalt = document.getElementById("btn-download-salt");
    const btnContinue = document.getElementById("btn-continue");
    const btnGoLogin = document.getElementById("btn-go-login");
    const saltNote = document.getElementById("salt-note");

    const enc = new TextEncoder();

    // show/hide helpers
    function showHidden(el, on) { el.classList.toggle("hidden", !on); }
    function showGate(on) { saltGate.classList.toggle("show", !!on); }
    function setBusy(b, text = "Contacting server…") {
      [chooseLogin, chooseRegister, btnLogin, btnRegister, btnBackFromLogin, btnBackFromRegister].forEach(el => { if (el) el.disabled = b; });
      overlay.classList.toggle("show", b);
      overlayText.textContent = text;
    }
    function error(el, msg) { el.textContent = msg || ""; }
    function okay(el, msg) { el.textContent = msg || ""; }

    // Landing choice
    function toChooser() {
      showHidden(chooser, true);
      showHidden(loginForm, false);
      showHidden(regForm, false);
      error(loginErr,""); error(regErr,""); okay(loginOk,""); okay(regOk,"");
    }
    chooseLogin.addEventListener("click", () => { showHidden(chooser,false); showHidden(loginForm,true); showHidden(regForm,false); loginEmail.focus(); });
    chooseRegister.addEventListener("click", () => { showHidden(chooser,false); showHidden(loginForm,false); showHidden(regForm,true); regEmail.focus(); });
    btnBackFromLogin.addEventListener("click", toChooser);
    btnBackFromRegister.addEventListener("click", toChooser);

    // Show/Hide passwords
    loginShowpw.addEventListener("change", (e) => {
      loginPassword.type = e.target.checked ? "text" : "password";
    });
    regShowpw.addEventListener("change", (e) => {
      regPassword.type = e.target.checked ? "text" : "password";
    });

    // ---- Encoding helpers ----
    function u8(x){ return new Uint8Array(x); }
    function bytesToBase64(bytes){ let s=""; for (const b of bytes) s+=String.fromCharCode(b); return btoa(s); }
    function base64ToBytes(b64){ const s=atob(b64); const a=new Uint8Array(s.length); for(let i=0;i<s.length;i++) a[i]=s.charCodeAt(i); return a; }
    function toBase64Url(bytes){ return bytesToBase64(bytes).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,""); }
    function makeShortId(n=6){ const a=new Uint8Array(n); crypto.getRandomValues(a); return Array.from(a).map(b=>b.toString(16).padStart(2,"0")).join(""); }

    // ---- PBKDF2+HKDF derivation ----
    async function pbkdf2Root(passwordStr, salt, iterations) {
      const key = await crypto.subtle.importKey("raw", enc.encode(passwordStr), "PBKDF2", false, ["deriveBits"]);
      const bits = await crypto.subtle.deriveBits({ name:"PBKDF2", salt, iterations, hash:"SHA-256" }, key, 256);
      return new Uint8Array(bits);
    }
    async function hkdfExpand(rootBytes, infoStr, outLen) {
      const hkdfKey = await crypto.subtle.importKey("raw", rootBytes, "HKDF", false, ["deriveBits"]);
      const info = new TextEncoder().encode(infoStr);
      const salt = new Uint8Array(0);
      const bits = await crypto.subtle.deriveBits({ name:"HKDF", hash:"SHA-256", salt, info }, hkdfKey, outLen*8);
      return new Uint8Array(bits);
    }

    function makeSaltObject(emailStr){
      const salt = new Uint8Array(16); crypto.getRandomValues(salt);
      return {
        v: 1,
        kdf: "pbkdf2-sha256",
        iterations: 600000,
        salt_b64: bytesToBase64(salt),
        email: (emailStr || ""), // optional; can be removed by user
        note: "Keep this file safe. Required to derive your login material and vault key. The `email` field is optional and may be blank or removed without affecting derivation.",
        salt,
      };
    }
    function buildDiskJson(saltObj){
      const { salt, ...disk } = saltObj;
      return JSON.stringify(disk, null, 2);
    }
    function suggestFilename(){ return `crs-salt-${makeShortId()}.json`; }
    function downloadText(filename, text){
      const blob = new Blob([text], { type: "application/json" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      setTimeout(() => { URL.revokeObjectURL(a.href); a.remove(); }, 0);
    }

    async function deriveFromSaltObj(passwordStr, saltObj) {
      const root = await pbkdf2Root(passwordStr, saltObj.salt, saltObj.iterations);
      const auth = await hkdfExpand(root, "crs:auth", 16);
      const vault = await hkdfExpand(root, "crs:vault", 32);
      return { auth_material_b64url: toBase64Url(auth), vault_key_b64: bytesToBase64(vault) };
    }

    async function readSaltFile(file) {
      if (!file) throw new Error("Please choose your salt file.");
      const text = await file.text();
      let o; try { o = JSON.parse(text); } catch { throw new Error("Salt file is not valid JSON."); }
      if (o?.kdf !== "pbkdf2-sha256" || typeof o?.iterations !== "number" || !o?.salt_b64) {
        throw new Error("Salt file is missing required fields.");
      }
      const salt = base64ToBytes(o.salt_b64);
      if (salt.length < 16) throw new Error("Salt in file is too short.");
      return { ...o, salt };
    }

    // ---- Initialize server vault on registration success ----
    export async function initVaultOnServer(vault_key_b64, email) {
      const now = new Date().toISOString();

      const scaffold = {
        version: 1,
        created_at: now,
        updated_at: now,
        private: {
          provider: {
            items: [],
            groups: {},
            synonyms: {}
          },
          requester: {
            items: [],
          }
        },
        meta: {
          schema: "crs/v1",
          owner: email || ""
        }
      };

      const key = await crypto.subtle.importKey("raw", base64ToBytes(vault_key_b64), { name:"AES-GCM" }, false, ["encrypt"]);
      const iv = new Uint8Array(12); crypto.getRandomValues(iv);
      const pt = new TextEncoder().encode(JSON.stringify(scaffold));
      const ctBuf = await crypto.subtle.encrypt({ name:"AES-GCM", iv }, key, pt);
      const blob = new Uint8Array(iv.length + ctBuf.byteLength);
      blob.set(iv, 0);
      blob.set(new Uint8Array(ctBuf), iv.length);
      const encrypted_localstore_b64 = bytesToBase64(blob);

      await api.saveToVault(encrypted_localstore_b64);
    }

    // ---- Salt Gate UI ----
    function openSaltGate({ mode, saltObj }) {
      const json = buildDiskJson(saltObj);
      const fname = suggestFilename();
      saltJsonEl.value = json;
      saltFilenameEl.textContent = fname;
      saltConfirm.checked = false;
      btnContinue.classList.toggle("hidden", mode !== "success");
      btnGoLogin.classList.toggle("hidden", mode !== "timeout");
      saltNote.textContent = (mode === "timeout")
        ? "We could not confirm registration due to a network timeout. Save this salt file now. Then try to log in. If login fails, try registering again and replace the old file."
        : "Save this salt file now. You’ll need it for future logins.";

      function updateProceed() {
        const enabled = saltConfirm.checked;
        btnContinue.disabled = !enabled;
        btnGoLogin.disabled = !enabled;
      }
      updateProceed();
      saltConfirm.onchange = updateProceed;

      btnDownloadSalt.onclick = () => downloadText(fname, json);
      btnContinue.onclick = () => { showGate(false); location.replace("/"); };
      btnGoLogin.onclick = () => {
        showGate(false);
        showHidden(chooser,false); showHidden(loginForm,true); showHidden(regForm,false);
        loginEmail.value = regEmail.value.trim();
        loginPassword.focus();
      };

      showGate(true);
    }

    // ---- Session helpers ----
    function setSessionVaultKey(vault_key_b64, email) {
      try { sessionStorage.setItem("crs:passkey", vault_key_b64); sessionStorage.setItem("crs:email", email); } catch {}
    }

    // ---- Login flow ----
    async function doLogin() {
      error(loginErr,""); okay(loginOk,"");
      setBusy(true);
      try {
        const em = loginEmail.value.trim();
        const pw = loginPassword.value;
        if (!em) throw new Error("Email is required.");
        if (!pw) throw new Error("Password is required.");
        const file = loginSaltfile.files?.[0];
        const saltObj = await readSaltFile(file);

        const { auth_material_b64url, vault_key_b64 } = await deriveFromSaltObj(pw, saltObj);
        await api.login(em, auth_material_b64url);

        setSessionVaultKey(vault_key_b64, em);
        location.replace("/app/dashboard.html");
      } catch (e) {
        error(loginErr, e?.data?.detail || e?.message || "Login failed");
      } finally {
        setBusy(false);
      }
    }

    // ---- Register flow (vault is created here, once) ----
    const REG_TIMEOUT_MS = 12000;
    let inMemSalt = null;

    function buildAbortable(ms) {
      const ac = new AbortController();
      const t = setTimeout(() => ac.abort(), ms);
      return { signal: ac.signal, cancel: () => clearTimeout(t) };
    }

    async function doRegister() {
      error(regErr,""); okay(regOk,"");
      setBusy(true, "Registering…");
      let abortCtl = null;
      try {
        const em = regEmail.value.trim();
        const pw = regPassword.value;
        if (!em) throw new Error("Email is required.");
        if (!pw) throw new Error("Password is required.");

        // Create/retain in-memory salt for this attempt
        if (!inMemSalt || inMemSalt.email !== em) {
          inMemSalt = makeSaltObject(em);
        }
        const { auth_material_b64url, vault_key_b64 } = await deriveFromSaltObj(pw, inMemSalt);

        // Abortable register
        abortCtl = buildAbortable(REG_TIMEOUT_MS);
        try {
          await api.register(em, auth_material_b64url, { signal: abortCtl.signal });
        } catch (e) {
          if (e.name === "AbortError") {
            // TIMEOUT: show salt gate (state unknown). No vault creation attempt here.
            setBusy(false);
            openSaltGate({ mode: "timeout", saltObj: inMemSalt });
            return;
          }
          throw e;
        } finally {
          abortCtl.cancel();
        }

        // Registration OK — create authoritative empty vault ONCE, server-side
        try {
          await initVaultOnServer(vault_key_b64, em);
        } catch (e) {
          // Not fatal for continuing, but inform the user at next screen (status on dashboard will say "Unsaved")
          console.error("Initial vault save failed:", e);
        }

        // Keep session key for dashboard, then show salt gate to force download & confirmation
        setSessionVaultKey(vault_key_b64, em);
        setBusy(false);
        openSaltGate({ mode: "success", saltObj: inMemSalt });
      } catch (e) {
        if (e?.status === 409 && e?.data?.detail === "Email already registered") {
          inMemSalt = null;
          okay(regOk, "This email already has an account. Please log in.");
          showHidden(regForm,false); showHidden(loginForm,true);
          loginEmail.value = regEmail.value.trim();
          loginPassword.focus();
        } else {
          error(regErr, e?.data?.detail || e?.message || "Registration failed");
        }
      } finally {
        setBusy(false);
      }
    }

    // Bind buttons
    document.getElementById("btn-login").addEventListener("click", (e) => { e.preventDefault(); doLogin(); });
    document.getElementById("btn-register").addEventListener("click", (e) => { e.preventDefault(); doRegister(); });

    // Enter key submits whichever form is visible (not inside salt gate)
    document.addEventListener("keydown", (e) => {
      if (saltGate.classList.contains("show")) return;
      if (e.key === "Enter" && !(e.ctrlKey||e.metaKey||e.shiftKey||e.altKey)) {
        if (!loginForm.classList.contains("hidden")) { e.preventDefault(); doLogin(); }
        else if (!regForm.classList.contains("hidden")) { e.preventDefault(); doRegister(); }
      }
    });
  </script>
</body>
</html>
