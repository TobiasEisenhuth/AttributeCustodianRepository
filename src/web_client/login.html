<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>CRS — Sign in / Register</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="/app/favicon.ico">
  <link rel="stylesheet" href="/app/style.css">
  <style>
    .alpha-note details {
      margin-top: 0.5rem;
    }
    .alpha-note summary {
      cursor: pointer;
      font-weight: 600;
      list-style: none;
    }
    .alpha-note summary::marker,
    .alpha-note summary::-webkit-details-marker {
      display: none;
    }
    .alpha-note {
      color: #333;
      font-size: 0.8rem;
      margin-top: 0.75rem;
    }
    .alpha-note ul {
      margin: 0.5rem 0 0 0;
      padding-left: 1.2rem;
    }
    .alpha-note li {
      margin-bottom: 0.25rem;
    }
    .alpha-note .warning-line {
      color: #b00;
      font-weight: 600;
    }
    .alpha-note a {
      color: #0a5;
      font-weight: 600;
      text-decoration: underline;
    }
    .alpha-note a:hover,
    .alpha-note a:focus {
      text-decoration: none;
    }
    .row { display:flex; gap:.5rem; align-items:center; }
    .buttons { display:flex; gap:.5rem; margin-top:.75rem; flex-wrap:wrap; }
    .buttons.right { justify-content:flex-end; }
    .error { color:#b00; min-height:1.25rem; }
    .ok { color:#0a5; min-height:1.25rem; }
    .muted { color:#666; font-size:.9rem; }
    .hint { font-size:.9rem; color:#444; }
    .hidden { display:none; }
    label > span { display:block; font-size:.85rem; color:#333; margin-bottom:.25rem; }
    input[type="password"] { letter-spacing:0.05em; }

    .overlay {
      position: absolute; inset: 0; display:none;
      background: rgba(255,255,255,0.65);
      backdrop-filter: blur(1px);
      align-items:center; justify-content:center; flex-direction:column; gap:.5rem;
      z-index: 10;
    }
    .overlay.show { display:flex; }
    .spinner {
      width: 28px; height: 28px; border-radius: 50%;
      border: 3px solid #999; border-top-color: transparent;
      animation: spin 0.8s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    .gate {
      position: fixed; inset: 0; display:none;
      background: rgba(0,0,0,0.45);
      align-items: center; justify-content: center;
      padding: 1rem; z-index: 20;
    }
    .gate.show { display:flex; }
    .gate-card {
      background: #fff; color: #111; max-width: 760px; width: 100%;
      border-radius: 12px; padding: 1rem; box-shadow: 0 4px 24px rgba(0,0,0,0.25);
      display: flex; flex-direction: column; gap: .75rem;
    }
    .gate-card h2 { margin: 0; }
    .gate-card .filename { font-family: monospace; background: #f3f3f3; padding: .25rem .5rem; border-radius: 6px; }
    .gate-card textarea {
      width: 100%; min-height: 220px; resize: vertical; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      border: 1px solid #ddd; border-radius: 8px; padding: .5rem; background: #fafafa; color:#222;
    }
    .gate-actions { display:flex; gap:.5rem; justify-content: flex-end; align-items:center; flex-wrap: wrap; }
    .gate-actions .left { margin-right: auto; display:flex; align-items:center; gap:.5rem; }
  </style>
</head>
<body class="center">
  <div class="card" id="card" aria-live="polite" style="position:relative;">
    <h1>Welcome to Consently</h1>
    <p>
      The origin of your personal digital data.<br/>
      Maintain your data in a single place and manage who can access which data.
    </p>

    <div id="alpha-note" class="alpha-note">
      <details>
        <summary class="warning-line">Disclaimer and known limitations (click to expand)</summary>
        <ul>
          <li>This is an early alpha preview. It is unaudited and NOT SECURE by any standard.</li>
          <li class="warning-line">DO NOT enter any data you would not be comfortable posting in public.</li>
          <li>Your user data (plain text and/or cipher) may be deleted at any time without notice.</li>
          <li>The email address provided at registration is processed and stored in plain text.</li>
          <li>
            While each secret's <code>label</code> and <code>value</code> are private and protected by design,<br>
            Consently can still trace who shares which secret (anonymized by ID) with whom.
          </li>
          <li>
            Hypothetically, a dishonest cloud provider could introspect Consently's virtual server's memory, and/or serve anything<br>
            (including a malicious Consently clone) to an unsuspecting user. Eventually, Consently will have to move to a device-agnostic client.
          </li>
          <li>
            The chosen re-encryption scheme (Umbral) is based on elliptic-curve cryptography and is therefore NOT post-quantum safe.<br>
            (Post-quantum-safe re-encryption schemes are an active research field. Consently intends to upgrade once a suitable implementation is available.)
          </li>
          <li>
            Similarly, the application-level E2EE of the request traffic is likewise based on elliptic-curve cryptography (WebCrypto ECDH P-256).<br>
            This is considered acceptable for now (low priority to upgrade).
          </li>
          <li>
            The global HTTPS traffic on the other hand, which wraps communication between your web client and the Consently server, is supposed to<br>
            use a post-quantum safe key agreement (x25519mlkem768), provided using a modern browser (x25519 else - not post-quantum safe).<br>
            This protects the most vulnerable stage of public key cryptography in a post-quantum safe manner (maybe, hopefully, allegedly, potentially).
          </li>
          <li>
            Your user store containing your labels and secret keys is encrypted symmetrically (AES-GCM) on the client-side before being saved to the server,<br>
            which is practically safe. BOTH your password AND salt file are absolutely required to decrypt your user store after fetching it from Consently.
          </li>
          <li>
            Using the web client will, unavoidably, have the browser (and by extension the operating system) deal with secrets in plain text in and memory.<br>
            Be sure to use a trustworthy personal device (phone, laptop, desktop), or boot your own live OS (like "Tails"), to access consently.online<br>
            from a foreign device.
          </li>
        </ul>
      </details>

      <p>
        <a href="https://github.com/TobiasEisenhuth/AttributeCustodianRepository/manual.md"
          target="_blank" rel="noopener">
          Check out the user manual on GitHub for usage and workflow.
        </a>
      </p>
    </div>

    <div id="chooser" class="buttons" style="justify-content:center; margin-top:1rem;">
      <button id="choose-login"  type="button">Login</button>
      <button id="choose-register" type="button">Register</button>
    </div>

    <!-- Login form -->
    <form id="login-form" class="hidden" autocomplete="on" method="post" action="/auth/login">
      <div class="row" style="margin-top:.5rem">
        <label style="flex:1">
          <span>Email</span>
          <input id="login-email" name="email" type="email" required autocomplete="username" />
        </label>
      </div>
      <div class="row" style="margin-top:.5rem">
        <label style="flex:1">
          <span>Password</span>
          <input id="login-password" name="password" type="password" required minlength="15" autocomplete="current-password" />
        </label>
        <label class="inline" title="Show password" style="display:flex; align-items:center; gap:.5rem;">
          <input id="login-showpw" type="checkbox" />
          <span class="muted">Show</span>
        </label>
      </div>
      <div class="row" style="margin-top:.5rem">
        <label style="flex:1">
          <span>Salt file (.json)</span>
          <input id="login-saltfile" name="saltfile" type="file" accept=".json,application/json" required />
        </label>
      </div>
      <div class="buttons" style="justify-content:space-between;">
        <button id="btn-back-from-login" type="button" class="muted">← Back</button>
        <div class="buttons right">
          <button id="btn-login" type="submit">Login</button>
        </div>
      </div>
      <p id="login-error" class="error" role="alert"></p>
      <p id="login-ok" class="ok" role="status"></p>
    </form>

    <!-- Register form -->
    <form id="register-form" class="hidden" autocomplete="on" method="post" action="/auth/register">
      <div class="row" style="margin-top:.5rem">
        <label style="flex:1">
          <span>Email</span>
          <input id="reg-email" name="email" type="email" required autocomplete="username" />
        </label>
      </div>
      <div class="row" style="margin-top:.5rem">
        <label style="flex:1">
          <span>Password</span>
          <input id="reg-password" name="password" type="password" required minlength="15" autocomplete="new-password" />
        </label>
        <label class="inline" title="Show password" style="display:flex; align-items:center; gap:.5rem;">
          <input id="reg-showpw" type="checkbox" />
          <span class="muted">Show</span>
        </label>
      </div>
      <p class="hint" style="margin-top:.5rem;">
        On registration we’ll create a <strong>device salt file</strong> (your second factor).
        We will only offer it for download <em>after</em> the server confirms registration (or if the connection times out).
        The <code>email</code> inside the file is optional and may be removed.
      </p>
      <div class="buttons" style="justify-content:space-between;">
        <button id="btn-back-from-register" type="button" class="muted">← Back</button>
        <div class="buttons right">
          <button id="btn-register" type="submit">Create account</button>
        </div>
      </div>
      <p id="reg-error" class="error" role="alert"></p>
      <p id="reg-ok" class="ok" role="status"></p>
    </form>

    <!-- Busy overlay -->
    <div id="overlay" class="overlay" aria-hidden="true">
      <div class="spinner" role="status" aria-label="Working…"></div>
      <div class="muted" id="overlay-text">Contacting server…</div>
    </div>

    <!-- Salt Gate -->
    <div id="salt-gate" class="gate" role="dialog" aria-modal="true" aria-labelledby="salt-gate-title" aria-describedby="salt-gate-desc">
      <div class="gate-card">
        <h2 id="salt-gate-title">Save your device salt file</h2>
        <p id="salt-gate-desc" class="muted">
          This file is required to log in from this device (and others if you copy it). Keep it safe.
          The <code>email</code> field is optional and only for your recognition; you may blank/remove it.
        </p>
        <div class="muted">Suggested filename: <span class="filename" id="salt-filename">crs-salt.json</span></div>
        <textarea id="salt-json" readonly spellcheck="false" aria-label="Salt file JSON"></textarea>
        <div class="gate-actions">
          <label class="left">
            <input id="salt-confirm" type="checkbox" />
            <span class="muted">I saved the file</span>
          </label>
          <button id="btn-download-salt" type="button">Download salt file</button>
          <button id="btn-continue" type="button" class="hidden">Continue to Dashboard</button>
          <button id="btn-go-login" type="button" class="hidden">Go to Login</button>
        </div>
        <p id="salt-note" class="muted"></p>
      </div>
    </div>
  </div>

  <script type="module">
    import { CRSClient } from "/app/crs-sdk.js";

    const api = new CRSClient();

    // Elements
    const overlay = document.getElementById("overlay");
    const overlayText = document.getElementById("overlay-text");
    const chooser = document.getElementById("chooser");
    const chooseLogin = document.getElementById("choose-login");
    const chooseRegister = document.getElementById("choose-register");

    const loginForm = document.getElementById("login-form");
    const loginEmail = document.getElementById("login-email");
    const loginPassword = document.getElementById("login-password");
    const loginShowpw = document.getElementById("login-showpw");
    const loginSaltfile = document.getElementById("login-saltfile");
    const btnLogin = document.getElementById("btn-login");
    const btnBackFromLogin = document.getElementById("btn-back-from-login");
    const loginErr = document.getElementById("login-error");
    const loginOk = document.getElementById("login-ok");

    const regForm = document.getElementById("register-form");
    const regEmail = document.getElementById("reg-email");
    const regPassword = document.getElementById("reg-password");
    const regShowpw = document.getElementById("reg-showpw");
    const btnRegister = document.getElementById("btn-register");
    const btnBackFromRegister = document.getElementById("btn-back-from-register");
    const regErr = document.getElementById("reg-error");
    const regOk = document.getElementById("reg-ok");

    const saltGate = document.getElementById("salt-gate");
    const saltJsonEl = document.getElementById("salt-json");
    const saltFilenameEl = document.getElementById("salt-filename");
    const saltConfirm = document.getElementById("salt-confirm");
    const btnDownloadSalt = document.getElementById("btn-download-salt");
    const btnContinue = document.getElementById("btn-continue");
    const btnGoLogin = document.getElementById("btn-go-login");
    const saltNote = document.getElementById("salt-note");

    const enc = new TextEncoder();

    // show/hide helpers
    function showHidden(el, on) { el.classList.toggle("hidden", !on); }
    function showGate(on) { saltGate.classList.toggle("show", !!on); }
    function setBusy(b, text = "Contacting server…") {
      [chooseLogin, chooseRegister, btnLogin, btnRegister, btnBackFromLogin, btnBackFromRegister].forEach(el => { if (el) el.disabled = b; });
      overlay.classList.toggle("show", b);
      overlayText.textContent = text;
    }
    function error(el, msg) { el.textContent = msg || ""; }
    function okay(el, msg) { el.textContent = msg || ""; }

    // Landing choice
    function toChooser() {
      showHidden(chooser, true);
      showHidden(loginForm, false);
      showHidden(regForm, false);
      error(loginErr,""); error(regErr,""); okay(loginOk,""); okay(regOk,"");
    }
    chooseLogin.addEventListener("click", () => {
      showHidden(chooser,false);
      showHidden(loginForm,true);
      showHidden(regForm,false);
      loginEmail.focus();
    });
    chooseRegister.addEventListener("click", () => {
      showHidden(chooser,false);
      showHidden(loginForm,false);
      showHidden(regForm,true);
      regEmail.focus();
    });
    btnBackFromLogin.addEventListener("click", toChooser);
    btnBackFromRegister.addEventListener("click", toChooser);

    // Show/Hide passwords
    loginShowpw.addEventListener("change", (e) => {
      loginPassword.type = e.target.checked ? "text" : "password";
    });
    regShowpw.addEventListener("change", (e) => {
      regPassword.type = e.target.checked ? "text" : "password";
    });

    // ---- Encoding helpers ----
    function bytesToBase64(bytes){
      let s = "";
      for (const b of bytes) s += String.fromCharCode(b);
      return btoa(s);
    }
    function base64ToBytes(b64){
      const s = atob(b64);
      const a = new Uint8Array(s.length);
      for (let i = 0; i < s.length; i++) a[i] = s.charCodeAt(i);
      return a;
    }
    function toBase64Url(bytes){
      return bytesToBase64(bytes)
        .replace(/\+/g,"-")
        .replace(/\//g,"_")
        .replace(/=+$/,"");
    }
    function makeShortId(n = 6){
      const a = new Uint8Array(n);
      crypto.getRandomValues(a);
      return Array.from(a)
        .map(b => b.toString(16).padStart(2,"0"))
        .join("");
    }

    // ---- PBKDF2+HKDF derivation ----
    async function pbkdf2Root(passwordStr, salt, iterations) {
      const key = await crypto.subtle.importKey("raw", enc.encode(passwordStr), "PBKDF2", false, ["deriveBits"]);
      const bits = await crypto.subtle.deriveBits({ name:"PBKDF2", salt, iterations, hash:"SHA-256" }, key, 256);
      return new Uint8Array(bits);
    }
    async function hkdfExpand(rootBytes, infoStr, outLen) {
      const hkdfKey = await crypto.subtle.importKey("raw", rootBytes, "HKDF", false, ["deriveBits"]);
      const info = enc.encode(infoStr);
      const salt = new Uint8Array(0);
      const bits = await crypto.subtle.deriveBits({ name:"HKDF", hash:"SHA-256", salt, info }, hkdfKey, outLen*8);
      return new Uint8Array(bits);
    }

    function makeSaltObject(emailStr){
      const salt = new Uint8Array(16);
      crypto.getRandomValues(salt);
      return {
        v: 1,
        kdf: "pbkdf2-sha256",
        iterations: 600000,
        salt_b64: bytesToBase64(salt),
        email: (emailStr || ""), // optional; can be removed by user
        note: "Keep this file safe. Required to derive your login material and vault key. The `email` field is optional and may be blank or removed without affecting derivation.",
        salt,
      };
    }
    function buildDiskJson(saltObj){
      const { salt, ...disk } = saltObj;
      return JSON.stringify(disk, null, 2);
    }
    function suggestFilename(){
      return `crs-salt-${makeShortId()}.json`;
    }
    function downloadText(filename, text){
      const blob = new Blob([text], { type: "application/json" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      setTimeout(() => {
        URL.revokeObjectURL(a.href);
        a.remove();
      }, 0);
    }

    async function deriveFromSaltObj(passwordStr, saltObj) {
      const root = await pbkdf2Root(passwordStr, saltObj.salt, saltObj.iterations);
      const auth = await hkdfExpand(root, "crs:auth", 16);
      const vault = await hkdfExpand(root, "crs:vault", 32);
      return {
        auth_material_b64url: toBase64Url(auth),
        vault_key_b64: bytesToBase64(vault)
      };
    }

    async function readSaltFile(file) {
      if (!file) throw new Error("Please choose your salt file.");
      const text = await file.text();
      let o;
      try {
        o = JSON.parse(text);
      } catch {
        throw new Error("Salt file is not valid JSON.");
      }
      if (o?.kdf !== "pbkdf2-sha256" || typeof o?.iterations !== "number" || !o?.salt_b64) {
        throw new Error("Salt file is missing required fields.");
      }
      const salt = base64ToBytes(o.salt_b64);
      if (salt.length < 16) throw new Error("Salt in file is too short.");
      return { ...o, salt };
    }

    // ---- E2EE: Inbox keypair generation (WebCrypto ECDH P-256) ----
    // We store keys as: base64(JSON(JWK))
    function jwkToB64(jwk) {
      const json = JSON.stringify(jwk);
      const bytes = enc.encode(json);
      return bytesToBase64(bytes);
    }

    async function generateInboxKeypair() {
      if (!crypto?.subtle) {
        throw new Error("WebCrypto not available for inbox key setup.");
      }

      const kp = await crypto.subtle.generateKey(
        { name: "ECDH", namedCurve: "P-256" },
        true,
        ["deriveBits"]
      );

      const publicJwk = await crypto.subtle.exportKey("jwk", kp.publicKey);
      const privateJwk = await crypto.subtle.exportKey("jwk", kp.privateKey);

      return {
        secret_key_b64: jwkToB64(privateJwk),
        public_key_b64: jwkToB64(publicJwk),
      };
    }

    // ---- Initialize server vault on registration success ----
    export async function initVaultOnServer(vault_key_b64, email, inboxKeys) {
      const now = new Date().toISOString();

      // This is the *persistent root object* that will become store.persistent
      const scaffold = {
        meta: {
          version: 1,
          created_at: now,
          updated_at: now,
          schema: "crs/v1",
          owner: email || "",
          inbox: inboxKeys ? {
            secret_key_b64: inboxKeys.secret_key_b64,
            public_key_b64: inboxKeys.public_key_b64,
            created_at: now,
            algo: "ECDH-P256-JWK",
            purpose: "solicitation-inbox-e2ee",
          } : undefined,
        }
      };

      // --- Build the SAME envelope shape extractStoreFromEnvelope expects ---

      async function deriveAesKeyPBKDF2(passkeyBytes, saltBytes, iterations = 100_000, keyLen = 256) {
        const keyMaterial = await crypto.subtle.importKey(
          "raw",
          passkeyBytes,
          { name: "PBKDF2" },
          false,
          ["deriveKey"]
        );
        return crypto.subtle.deriveKey(
          {
            name: "PBKDF2",
            salt: saltBytes,
            iterations,
            hash: "SHA-256",
          },
          keyMaterial,
          { name: "AES-GCM", length: keyLen },
          false,
          ["encrypt", "decrypt"]
        );
      }

      const persistent_utf_8 = JSON.stringify(scaffold);
      const persistent_bytes = enc.encode(persistent_utf_8);

      const salt = new Uint8Array(16);
      crypto.getRandomValues(salt);
      const nonce = new Uint8Array(12);
      crypto.getRandomValues(nonce);

      // IMPORTANT: passkey here is the *string* you store in sessionStorage ("crs:passkey")
      // which is your vault_key_b64.
      const key = await deriveAesKeyPBKDF2(enc.encode(vault_key_b64), salt, 100_000);

      const ctBuf = await crypto.subtle.encrypt(
        { name: "AES-GCM", iv: nonce },
        key,
        persistent_bytes
      );

      const envelope = {
        v: 1,
        enc: "aes-256-gcm",
        kdf: "pbkdf2-sha256",
        iterations: 100_000,
        salt_b64: bytesToBase64(salt),
        nonce_b64: bytesToBase64(nonce),
        ct_b64: bytesToBase64(new Uint8Array(ctBuf)),
      };

      const envelope_bytes = enc.encode(JSON.stringify(envelope));
      const envelope_b64 = bytesToBase64(envelope_bytes);

      await api.saveToVault(envelope_b64);
    }

    // ---- Salt Gate UI ----
    function openSaltGate({ mode, saltObj }) {
      const json = buildDiskJson(saltObj);
      const fname = suggestFilename();
      saltJsonEl.value = json;
      saltFilenameEl.textContent = fname;
      saltConfirm.checked = false;
      btnContinue.classList.toggle("hidden", mode !== "success");
      btnGoLogin.classList.toggle("hidden", mode !== "timeout");
      saltNote.textContent = (mode === "timeout")
        ? "We could not confirm registration due to a network timeout. Save this salt file now. Then try to log in. If login fails, try registering again and replace the old file."
        : "Save this salt file now. You’ll need it for future logins.";

      function updateProceed() {
        const enabled = saltConfirm.checked;
        btnContinue.disabled = !enabled;
        btnGoLogin.disabled = !enabled;
      }
      updateProceed();
      saltConfirm.onchange = updateProceed;

      btnDownloadSalt.onclick = () => downloadText(fname, json);
      btnContinue.onclick = () => {
        showGate(false);
        location.replace("/");
      };
      btnGoLogin.onclick = () => {
        showGate(false);
        showHidden(chooser,false);
        showHidden(loginForm,true);
        showHidden(regForm,false);
        loginEmail.value = regEmail.value.trim();
        loginPassword.focus();
      };

      showGate(true);
    }

    // ---- Session helpers ----
    function setSessionVaultKey(vault_key_b64, email) {
      try {
        sessionStorage.setItem("crs:passkey", vault_key_b64);
        sessionStorage.setItem("crs:email", email);
      } catch {}
    }

    // ---- Login flow ----
    async function doLogin() {
      error(loginErr,"");
      okay(loginOk,"");

      if (!loginForm.reportValidity()) {
        return;
      }
      setBusy(true);
      try {
        const em = loginEmail.value.trim();
        const pw = loginPassword.value;

        if (!em) throw new Error("Email is required.");
        if (!pw) throw new Error("Password is required.");

        const file = loginSaltfile.files?.[0];
        const saltObj = await readSaltFile(file);

        const { auth_material_b64url, vault_key_b64 } = await deriveFromSaltObj(pw, saltObj);
        await api.login(em, auth_material_b64url);

        setSessionVaultKey(vault_key_b64, em);
        location.replace("/app/dashboard.html");
      } catch (e) {
        error(loginErr, e?.data?.detail || e?.message || "Login failed");
      } finally {
        setBusy(false);
      }
    }

    // ---- Register flow (vault is created here, once) ----
    const REG_TIMEOUT_MS = 12000;
    let inMemSalt = null;

    function buildAbortable(ms) {
      const ac = new AbortController();
      const t = setTimeout(() => ac.abort(), ms);
      return {
        signal: ac.signal,
        cancel: () => clearTimeout(t)
      };
    }

    async function doRegister() {
      error(regErr,"");
      okay(regOk,"");

      if (!regForm.reportValidity()) {
        return;
      }

      setBusy(true, "Registering…");
      let abortCtl = null;
      try {
        const em = regEmail.value.trim();
        const pw = regPassword.value;
        if (!em) throw new Error("Email is required.");
        if (!pw) throw new Error("Password is required.");

        if (!inMemSalt || inMemSalt.email !== em) {
          inMemSalt = makeSaltObject(em);
        }
        const { auth_material_b64url, vault_key_b64 } = await deriveFromSaltObj(pw, inMemSalt);

        abortCtl = buildAbortable(REG_TIMEOUT_MS);
        try {
          await api.register(em, auth_material_b64url, { signal: abortCtl.signal });
        } catch (e) {
          if (e.name === "AbortError") {
            setBusy(false);
            openSaltGate({ mode: "timeout", saltObj: inMemSalt });
            return;
          }
          throw e;
        } finally {
          abortCtl.cancel();
        }

        setBusy(true, "Bootstrapping E2EE keys…");
        let inboxKeys = null;
        try {
          inboxKeys = await generateInboxKeypair();
          await api.upsertInboxPublicKey(inboxKeys.public_key_b64);
        } catch (e) {
          throw new Error(
            "Account created, but failed to initialize your E2EE inbox keys. " +
            "Please try logging in again and contact support if this persists."
          );
        }

        setBusy(true, "Creating your vault…");
        try {
          await initVaultOnServer(vault_key_b64, em, inboxKeys);
        } catch (e) {
          console.error("Initial vault save failed:", e);
        }

        setSessionVaultKey(vault_key_b64, em);
        setBusy(false);
        openSaltGate({ mode: "success", saltObj: inMemSalt });
      } catch (e) {
        if (e?.status === 409 && e?.data?.detail === "Email already registered") {
          inMemSalt = null;
          okay(regOk, "This email already has an account. Please log in.");
          showHidden(regForm,false);
          showHidden(loginForm,true);
          loginEmail.value = regEmail.value.trim();
          loginPassword.focus();
        } else {
          error(regErr, e?.data?.detail || e?.message || "Registration failed");
        }
      } finally {
        setBusy(false);
      }
    }

    loginForm.addEventListener("submit", (e) => {
      e.preventDefault();
      doLogin();
    });

    regForm.addEventListener("submit", (e) => {
      e.preventDefault();
      doRegister();
    });

    // Enter key submits whichever form is visible (not inside salt gate)
    document.addEventListener("keydown", (e) => {
      if (saltGate.classList.contains("show")) return;
      if (e.key === "Enter" && !(e.ctrlKey || e.metaKey || e.shiftKey || e.altKey)) {
        if (!loginForm.classList.contains("hidden")) {
          e.preventDefault();
          loginForm.requestSubmit(btnLogin);
        } else if (!regForm.classList.contains("hidden")) {
          e.preventDefault();
          regForm.requestSubmit(btnRegister);
        }
      }
    });

    toChooser();
  </script>
</body>
</html>
